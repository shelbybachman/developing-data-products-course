?confint
confint(fit)
?mtcars
?confint
confint(fit, parm = 'wt')
predict(fit, data.frame(wt = 3))
predict(fit, data.frame(wt = 3))
predict(confint(fit, parm='w't), data.frame(wt = 3))
predict(confint(fit, parm='wt'), data.frame(wt = 3))
meanVal <- mean(mtcars$mpg)
summary(fit)
predict(fit, data.frame(wt = 3))
predict(fit)
predict(fit, data.frame(wt = mean(mtcars$wt)))
37.2851 + (confint(fit)[1])
confint(fit)
37.2851 + (confint(fit, 'parm')[1])
37.2851 + (confint(fit, 'wt')[1])
37.2851 + (confint(fit, 'wt')[1])*meanVl
37.2851 + (confint(fit, 'wt')[1])*meanVal
fit
predict(fit, data = data.frame(wt = meanVal), interval = 'confidence')
meanVal
fit
data = data.frame(wt = meanVal)
data
data
predict(fit, data, interval = 'confidence')
meanVal <- mean(mtcars$wt)
predict(fit, data, interval = 'confidence')
data = data.frame(wt = meanVal)
predict(fit, data, interval = 'confidence')
predict(fit, data = data.frame(wt = 1), interval = 'confidence')
predict(fit, data = data.frame(wt = 1), interval = 'confidence')
data = data.frame(wt = 3)
predict(fit, data, interval = 'confidence')
fit
data
data = data.frame(wt = 3)
37.285 + (-5.344*3)
data = data.frame(wt = c(1,2,3))
data
predict(fit, data, interval = 'confidence')
data = data.frame(wt = c(1,2,3,4))
predict(fit, data, interval = 'confidence')
fit
y.fitted <- fit$fitted.values
b0 <- fit$coefficients[1]
b1 <- fit$coefficients[2]
pred.y <- b0 + b1 * 3
pred.y
pred.x <- 3
t.val <- qt(0.975,nrow(mtcars)-2)
data
data = data.frame(wt = 3)
predict(fit, data, interval = 'prediction')
ntcars
mtcars
mtcars$wt_ton <- mtcars$wt/2
fit <- lm(mpg ~ wt_ton, data=mtcars)
summary(fit)
fit <- lm(mpg ~ wt, mtcars)
fit_denom <- lm(mpg ~ 1, mtcars)
sum(resid(fit)^2)/sum(resid(fit_denom)^2)
library(swirl)
swirl()
6
dim(InsectSprays)
head(InsectSprays)
head(InsectSprays, 15)
sA
summary(InsectSprays[,2])
sapply(InsectSprays, class)
fit <- lm(count ~ spray, data=InsectSprays)
fit$coef
summary(fit)$coef
est <- summary(fit$coef[,1])
est <- summary(fit)$coef[,1]
mean(sA)
mean(sB)
nfit <- lm(count ~ spray - 1, data = InsectSprays)
summary(nfit)$coef
spray2 <- relevel(InsectSprays$spray, "C")
fit2 <- lm(count ~ spray, data = InsectSprays)
fit2 <- lm(count ~ spray2, data = InsectSprays)
summary(fit2)$coef
mean(sC)
(fit$coef[2] - fit$coef[3])/1.6011
dim(hunger)
948
names(hunger)
fit <- lm(Numeric ~ Year, data = hunger)
summary(fit)$coef
lmF <- lm(hunger$Numeric[hunger$Sex=='Female'] ~ hunger$Year[hunger$Sex=='Female'], data = hunger)
lmF <- lm(hunger$Numeric[hunger$Sex=='Male'] ~ hunger$Year[hunger$Sex=='Male'], data = hunger)
lmM <- lm(hunger$Numeric[hunger$Sex=='Male'] ~ hunger$Year[hunger$Sex=='Male'], data = hunger)
lmBoth <- lm(Numeric ~ Year + Sex, data = hunger)
summary(lmBoth)
lmInter <- lm(Numeric ~ Sex*Year, data=hunger)
summary(lmInter)
fit <- lm(y ~ x, data=out2)
plot(fit, which=1)
fitno<- lm(y ~ x, data=out2[-1,])
plot(fit, which=1)
plot(fitno,which=1)
coef(fit) - coef(fitno)
head(dfbeta(fit))
resno <- out2[1,"y"] - predict(fitno, out2[1,])
1-resid(fit)[1]/resno
hatvalues(fit)
head(hatvalues(fit))
}))
fit$residuals
sigma <- sqrt(deviance(fit)/df.residual(fit))
rstd <- fit$residuals / (sigma*sqrt(1-hatvalues(fit)))
head(cbind(rstd, rstandard(fit)))
plot(fit, which=3)
plot(fit,which=2)
sigma1 <- sqrt(deviance(fitno)/df.residual(fitno))
resid(fit)[1]/(sigma*sqrt(1-hatvalues(fit)[1]))
resid(fit)[1]/(sigma1*sqrt(1-hatvalues(fit)[1]))
head(rstudent(fit))
dy <- predict(fitno, out2) - predict(fit, out2)
sum(dy)^2 / (2*sigma^2)
sum(dy^2) / (2*sigma^2)
plot(fit,which=5)
x <- -5:5
y <- c(5.12, 3.93, 2.67, 1.87, 0.52, 0.08, 0.93, 2.05, 2.54, 3.87, 4.97)
knots <- seq(0,8*pi,length=20)
knots
plot(knots)
splineTerms <- sapply(knots, function(knot) (x > knot) * (x - knot))
plot(splineTerms)
knots <- seq(-5,5,length=20)
splineTerms <- sapply(knots, function(knot) (x > knot) * (x - knot))
plot(splineTerms)
plot(knots)
plot(knots, splineTerms)
plot(x, knots)
plot(x, splineTerms)
splineTerms
knots <- x
splineTerms <- sapply(knots, function(knot) (x > knot) * (x - knot))
splineTerms
knots
install.packages('crossdes')
library(crossdes)
des.MOLS(4, 8)
des.MOLS(4, 4)
find.BIB(4, 52, 8, )
find.BIB(4, 52, 8)
find.BIB(8, 52, 8)
find.BIB(8, 52, 8, 1000)
all.combin(4, 8)
all.combin(4, 8)
des.MOLS(8, 8)
des.MOLS(4)
citation(package = "base")
install.packages('gdata')
library(gdata)
install.packages('caret')
library(caret)
install.packages('splines')
library(splines)
library(caret)
library(kernlab)
data(spam)
inTrain <- createDataPartition(y=spam$type, p=0.75, list=FALSE)
training <- spam[inTrain,]
testing <- spam[-inTrain,]
M <- abs(cor(training[,-58]))
M
diag(M) <- 0
which(M > 0.8, arr.ind = T)
names(spam)[c(32,34)]
plot(spam[,34],spam[,32])
smallSpam <- spam[,c(34,32)]
prComp <- prcomp(smallSamp)
prComp <- prcomp(smallSpam)
plot(prComp$x[,1], prComp$x[,2])
prComp$rotation
vec1 <- c(1, 2, 3)
vec2 <- c(4, 5, 6)
vec3 <- c(7, 8, 9)
[vec1,vec2,vec3]
as.matrix(vec1,vec2,vec3)
as.matrix(vec1)
as.matrix(vec1'')
[vec1,]
vec1
?as.matrix
matrix(c(vec1,vec2,vec3), nrow=2,ncol = 3)
matrix(c(vec1,vec2,vec3), nrow=3,ncol = 3)
matrix(c(vec1,vec2,vec3), nrow=3,ncol = 3, byrow = TRUE)
temp <- matrix(c(vec1,vec2,vec3), nrow=3,ncol = 3, byrow = TRUE)
dims(temp)
dim(temp)
temp
temp[,4] <- c(10, 10, 10)
temp[:,4] <- c(10, 10, 10)
temp <- c(10, 10, 10)
temp
temp <- matrix(c(vec1,vec2,vec3), nrow=3,ncol = 3, byrow = TRUE)
temp
vector_a <- c(2, 5, 7)
vector_b <- vector_a^2
# find the square root of the sum of x-squared and y-squared; don't store it as a variable
sqrt(x^2 + y ^ 2)
# create a variable 'x' equal to the number 2
x <- 2
# create another variable 'y' equal to the number 5
y <- 5
# now add x and y together, and store the result in a third variable 'z'
z <- x + y
z
4 + 25
# clear the workspace
rm(list = ls())
# create an object 'x' equal to the number 2
x <- 2
# create an object 'y' equal to the number 3
y <- 3
x+y
y-x
# take the square of x
x^2
# now add x and y together, and store the result in a third object 'z'
z <- x + y
# find the square root of the sum of x-squared and y-squared
sqrt(x^2 + y^2)
# create a vector 'vector_a' containing the variables x, y, and z
vector_a <- c(x, y, z)
vector_a
class(vector_a)
# print the second element of vector_a
vector_a[2]
# compute the number of elements in vector_a
length(vector_a)
?length
# compute the number of unique elements in vector_a
unique(vector_a)
length(unique(vector_a))
# determine whether the third element of vector_a is greater than 5
vector_a[3] > 5
vector_a[3] == 5
vector_a == 5
# create a vector 'vector_b' containing the squares of x, y, and z
vector_b <- c(x^2, y^2, z^2)
vector_a^2
vector_b == vector_a^2
c('shelby', 'briana', 'sumedha')
?matrix
# create a matrix 'our_matrix' containing vector_a in column 1 and vector_b in column 2
our_matrix <- matrix(c(vector_a, vector_b), nrow = 3, ncol = 2, byrow = FALSE)
our_matrix
# get the dimensions of our_matrix
dim(our_matrix)
nrow(our_matrix)
ncol(our_matrix)
# create a matrix 'our_matrix' containing vector_a in column 1 and vector_b in column 2
our_matrix <- matrix(c(vector_a, vector_b), nrow = 3, ncol = 2, byrow = FALSE)
our_matrix
# print just the first column of our_matrix
our_matrix[,1]
# print the number in the 3rd row & 2nd column of our_matrix
our_matrix[3,2]
# take the row-wise sum of columns 1 & 2 of our_matrix
our_matrix[,1] + our_matrix[,2]
# add a third column to our_matrix, consisting of the row-wise sum of columns 1 & 2
our_matrix <- matrix(c(our_matrix, (our_matrix[,1]+our_matrix[,2])), nrow = 3, ncol = 3, byrow = FALSE)
our_matrix
# clear the workspace
rm(list = ls())
# create an object 'x' equal to the number 2
x <- 2
# create an object 'y' equal to the number 3
y <- 3
# take the square of x
x^2
# now add x and y together, and store the result in a third object 'z'
z <- x + y
# find the square root of the sum of x-squared and y-squared
sqrt(x^2 + y^2)
# create a vector 'vector_a' containing the variables x, y, and z
vector_a <- c(x, y, z)
# print the second element of vector_a
vector_a[2]
# compute the number of elements in vector_a
length(vector_a)
# show the help screen for the length() function
?length
# compute the number of unique elements in vector_a
unique(vector_a)
length(unique(vector_a))
# determine whether the third element of vector_a is greater than 5
vector_a[3] > 5
vector_a[3] == 5
vector_a == 5
# create a vector 'vector_b' containing the squares of x, y, and z
vector_b <- c(x^2, y^2, z^2)
vector_a^2
vector_b == vector_a^2
# create a matrix 'our_matrix' containing vector_a in column 1 and vector_b in column 2
our_matrix <- matrix(c(vector_a, vector_b), nrow = 3, ncol = 2, byrow = FALSE)
our_matrix
# get the dimensions of our_matrix
dim(our_matrix)
nrow(our_matrix)
ncol(our_matrix)
# print just the first column of our_matrix
our_matrix[,1]
# print the number in the 3rd row & 2nd column of our_matrix
our_matrix[3,2]
# take the row-wise sum of columns 1 & 2 of our_matrix
our_matrix[,1] + our_matrix[,2]
# add a third column to our_matrix, consisting of the row-wise sum of columns 1 & 2
our_matrix <- matrix(c(our_matrix, (our_matrix[,1]+our_matrix[,2])), nrow = 3, ncol = 3, byrow = FALSE)
our_matrix
# convert our_matrix to a dataframe, and store it as 'our_dataframe'
our_dataframe <- as.data.frame(our_matrix)
our_dataframe
# give our dataframe some columns names by creating a character vector
names(our_dataframe) <- c('a', 'a_squared', 'sum')
our_dataframe
?c
# now we can check that the column names were applied
names(our_dataframes)
# now we can check that the column names were applied
names(our_dataframe)
nrow(our_dataframe)
nrcol(our_dataframe)
ncol(our_dataframe)
# print the sum column
our_dataframe$sum
# print the second value in the a_squared column
our_dataframe$a_squared[2]
# add a new column to our_dataframe equal to the square root of the sum, named 'sum_sqrt'
our_dataframe$sum_sqrt <- sqrt(our_dataframe$sum)
our_dataframe
# take the sum of the new 'sum_sqrt' column
sum(our_dataframe$sum_sqrt)
# load the ToothGrowth dataset that is built into R
data(ToothGrowth)
View(ToothGrowth)
# first, we should explore the dataset
# display the first 10 rows of the dataframe
head(ToothGrowth, 10)
# the str() function gives a more comprehensive summary of the variables in a dataframe
# it shows the number of observations, variables, each variable's class, and # of levels
str(ToothGrowth)
# sometimes we want to get a count of the number of observations of one variable
# create a table showing the number of observations for each dose
table(ToothGrowth$dose)
# create a table showing number of observations where dose is greater than 1
table(ToothGrowth$dose > 1)
# create a table showing number of observations for each dose for each supplement type
table(ToothGrowth$dose, ToothGrowth$supp)
# the summary() command allows us to get the min, max, mean, and median of all numeric variables
summary(ToothGrowth)
# find the maximum, minimum, and range of the tooth length values
max(ToothGrowth$len)
min(ToothGrowth$len)
range(ToothGrowth$len)
range(ToothGrowth$len)[1]
# find the mean tooth length, stripping NAs if they exist
mean(ToothGrowth$len)
is.na(ToothGrowth$len)
table(is.na(ToothGrowth$len))
?mean
mean(ToothGrowth$len, na.rm = TRUE)
# find the standard deviation of tooth length
sd(ToothGrowth$len, na.rm = TRUE)
# make a histogram of tooth length in the guinea pigs
hist(ToothGrowth$len)
# make some aesthetic improvements to the plot
?hist
hist(ToothGrowth$len,
xlab = "Tooth Length", ylab = "Frequency",
main = "Histogram of tooth length",
col = "aqua")
hist(ToothGrowth$len,
xlab = "Tooth Length", ylab = "Frequency",
main = "Histogram of tooth length",
col = "turquoise")
# create a new variable in the ToothLength dataframe 'randNumber' consisting of a random number
?rnorm
ToothGrowth$randNumber <- rnorm(nrow(ToothGrowth))
head(ToothGrowth, 10)
?plot
# make a scatterplot of tooth length vs. the random number
plot(ToothGrowth$len, ToothGrowth$randNumber)
?plot
# make some aesthetic improvements ot the plot
plot(ToothGrowth$len, ToothGrowth$randNumber,
xlab = "Tooth length", ylab = "Random number",
main = "Scatterplot",
col = "magenta")
?boxplot
# make a boxplot of tooth length vs. supplementation method
boxplot(len ~ supp, ToothGrowth,
xlab = 'supplementation method', ylab = 'tooth length',
main = 'boxplot of tooth length by supp. method')
# make a boxplot of tooth length by supplementation method AND dose
boxplot(len ~ supp:dose, ToothGrowth,
xlab = 'supplementation method', ylab = 'tooth length',
main = 'boxplot of tooth length by supp. method')
?t.test
# it looks like there is an effect of supplementation method on tooth length.
# do a t-test to determine whether tooth length differs significantly by supplement.
t.test(len ~ supp, data = ToothGrowth, paired = FALSE)
# you can also store the results of your statistical test in an object
our_ttest <- t.test(len ~ supp, data = ToothGrowth, paired = FALSE)
# the result is a list with 9 elements. use the following syntax to print each element:
our_ttest[[3]] # prints the p-value
our_ttest[[1]] # prints the t-statistic
# it also looked like there was an effect of dose on tooth length.
# do an ANOVA to determine whether there is a significant effect of dose on tooth length
our_anova <- aov(len ~ dose, data = ToothGrowth)
summary(our_anova)
# it also looked like there was an effect of dose on tooth length.
# do an ANOVA to determine whether there is a significant effect of dose on tooth length
our_anova <- aov(len ~ dose * supp, data = ToothGrowth)
summary(our_anova)
?library
??dplyr
# importing .csv data
# preferred method is using the fread() function within the data.table package
?fread
library(data.table)
?fread
getwd()
?read.csv
getwd()
myWd <- getwd()
# save your current directory as an R-object
myDir <- getwd()
myDir
?sep
vec(myDir, '/data', sep=/)
print(myDir, 'data', sep='/')
?print
cat(myDir, '/data',sep='')
library(rprojroot)
View(path)
install.packages('devtools')
devtools::install_github('jwdink/eyetrackingR')
library(eyetrackingR)
install.packages('shiny')
library(shiny)
runApp('Documents/Coursera/Developing Data Products/shiny/myApp')
setwd("~/Documents/Coursera/Developing Data Products/shiny/myApp")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('~/Documents/Coursera/Developing Data Products/shiny/myPlotApp')
runApp('~/Documents/Coursera/Developing Data Products/shiny/myPlotApp')
runApp('~/Documents/Coursera/Developing Data Products/shiny/app_predict')
runApp('~/Documents/Coursera/Developing Data Products/shiny/app_predict_button')
runApp('~/Documents/Coursera/Developing Data Products/shiny/app_predict_button')
runApp('~/Documents/Coursera/Developing Data Products/shiny/app_tab')
runApp('~/Documents/Coursera/Developing Data Products/shiny/app_tab')
runApp('~/Documents/Coursera/Developing Data Products/shiny/app_interactivePlot')
install.packages('miniUI')
library(shiny)
library(miniUI)
myFirstGadget <- function() {
ui <- miniPage( # mini UI page layout
gadgetTitleBar("My First Gadget")
)
server <- function(input, output, session) {
# the DONE button closes the app
observeEvent(input$done, {
stopApp()
})
}
runGadget(ui, server)
}
myFirstGadget
mylibrary(shiny)
library(miniUI)
library(shiny)
myFirstGadget <- function() {
ui <- miniPage( # mini UI page layout
gadgetTitleBar("My First Gadget")
)
server <- function(input, output, session) {
# the DONE button closes the app
observeEvent(input$done, {
stopApp()
})
}
runGadget(ui, server)
}
rm(list = ls())
# load required packages
library(shiny)
library(miniUI)
myFirstGadget <- function() {
ui <- miniPage( # mini UI page layout
gadgetTitleBar("My First Gadget")
)
server <- function(input, output, session) {
# the DONE button closes the app
observeEvent(input$done, {
stopApp()
})
}
runGadget(ui, server)
}
myFirstGadget()
